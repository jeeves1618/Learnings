<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Big O</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link type="text/css" rel="stylesheet" href="css/topic.css" />
  </head>
  <body>
    <header id="main-header">
      <a href="index.html" id="logo">Data Structures & Algorithms</a>
      <nav>
        <ul>
          <li><a href="">Books</a></li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
      <a href="#side-drawer" class="menu-btn"
        ><span></span><span></span><span></span
      ></a>
    </header>
    <aside id="side-drawer">
      <header id="sub-header">
        <a href="index.html" id="sublogo">Data Structures & Algorithms</a>
        <a href="#" class="menu-btn"><span></span><span></span><span></span></a>
      </header>
      <nav>
        <ul>
          <li><a href="">Books</a></li>
          <li><a href="">Courses</a></li>
        </ul>
      </nav>
    </aside>
    <main>
      <h1>Big O Notation</h1>
      <section id="latest-products">
        <ul>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Introduction</h2>
                <p>
                  A good code should be readable and scalable. Big O is used to
                  measure the scalability of the code.
                </p>
                <p>
                  Big O Asymptotic Notation, or simply the Big O notation,
                  describes the worst-case running time of a program. We compute
                  the Big-O of an algorithm by counting how many iterations an
                  algorithm will take in the worst-case scenario with an input
                  of N. We typically consult the Big-O because we must always
                  plan for the worst case.
                </p>
                <p>
                  Big O is used to measure the time and space complexity of an
                  algorithm.
                </p>
                <p>
                  Here is the link to
                  <a
                    href="https://zerotomastery.io/cheatsheets/big-o-cheat-sheet/?utm_source=udemy&utm_medium=coursecontent"
                    target="_blank"
                  >
                    summary of Big O</a
                  >
                  from AtoZ Mastery site
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">The notations</h2>
                <p>
                  <code class="language-text">O(1)</code> Constant - no loops
                </p>
                <p>
                  <code class="language-text">O(log N)</code> Logarithmic -
                  usually searching algorithms have log n if they are sorted
                  (Binary Search)
                </p>
                <p>
                  <code class="language-text">O(n)</code> Linear - for loops,
                  while loops through n items
                </p>
                <p>
                  <code class="language-text">O(n log(n))</code> Log Linear -
                  usually sorting operations
                </p>
                <p>
                  <code class="language-text">O(n^2)</code> Quadratic - every
                  element in a collection needs to be compared to ever other
                  element. Two nested loops
                </p>
                <p>
                  <code class="language-text">O(2^n)</code> Exponential -
                  recursive algorithms that solves a problem of size N
                </p>
                <p>
                  <code class="language-text">O(n!)</code> Factorial - you are
                  adding a loop for every element
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">What it means?</h2>
                <table>
                  <thead>
                    <tr>
                      <th>Big O</th>
                      <th>Name</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>1</td>
                      <td>Constant</td>
                      <td>statement, one line of code</td>
                    </tr>
                    <tr>
                      <td>log(n)</td>
                      <td>Logarithmic</td>
                      <td>Divide and conquer (binary search)</td>
                    </tr>
                    <tr>
                      <td>n</td>
                      <td>Linear</td>
                      <td>Loop</td>
                    </tr>
                    <tr>
                      <td>n*log(n)</td>
                      <td>Linearithmic</td>
                      <td>Effective sorting algorithms</td>
                    </tr>
                    <tr>
                      <td>n^2</td>
                      <td>Quadratic</td>
                      <td>Double loop</td>
                    </tr>
                    <tr>
                      <td>n^3</td>
                      <td>Cubic</td>
                      <td>Triple loop</td>
                    </tr>
                    <tr>
                      <td>2^n</td>
                      <td>Exponential</td>
                      <td>Complex full search</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Time lapse is a bad measure</h2>
                <p>
                  This
                  <a
                    href="https://github.com/jeeves1618/DSandAlgo/blob/master/exercises/BigO.js"
                    >piece of code</a
                  >
                  attempts to measure the performance in terms of elapsed time
                  (in milli seconds). This measure is dependent on the hardware
                  resources and CPU availability and cannot be standardized
                  across machines or across different times in the same machine.
                  And it does not say anything about how quickly our runtime
                  grows and cannot be used as a measure for scalability.
                </p>
                <p>
                  Big O standardizes the measure across the CPUs by counting the
                  operations for an array of inputs.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">O(1) Notation</h2>
                <p>
                  When the time complexity is a function of constant time, be it
                  O(1) or O(2), independent of the input elements, we call it
                  O(1). The
                  <a
                    href="https://github.com/jeeves1618/DSandAlgo/blob/master/exercises/Oof1.js"
                    >piece of code</a
                  >
                  explains O(1). What ever the number of the inputs are, we
                  perform only one operation.
                </p>
                <p>
                  So, it qualifies as O(1) time complexity operation. But, is
                  the space complexity also 1?
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">O(N) Notation</h2>
                <p>
                  As you can see in this
                  <a
                    href="https://github.com/jeeves1618/DSandAlgo/blob/master/exercises/OofN.js"
                    >piece of code</a
                  >
                  the mumber of operations increases linearly with the number of
                  inputs. It can be N operations for N inputs ot 2N operations
                  for N inputs. We will omit the constant and call it a O(N)
                  time complexity.
                </p>
                <p>
                  This is also called a <strong>linear time notation</strong>.
                  That is, as the number of inputs increases, the number of
                  operations increases in linear proportion.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Four Rules of Big O</h2>
                <p>
                  1. Always consider the worst case. In searching through an
                  array of n elements, always consider the case where the
                  element you are searching for is the nth element. Since there
                  is a possibility of iterating till nth element, the time
                  complexity is always O(N)
                </p>
                <p>
                  2. Ignore the constant number of iterations. For instance, if
                  you are iterating an annual journal entry file once (O(N)) and
                  then have an iteration for 365 days in an year, you can safely
                  ignore the 365 iterations. Because, that is not going to scale
                  up with the inputs.
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Four Rules of Big O - Cont...</h2>
                <p>
                  3. Different inputs should be considered separately. For
                  instance, if you are iterating the same input twice, it will
                  become O(2N) and since we have to ignore the constants, it
                  will become O(N). But, if you are iterating on two inputs, a
                  and b, they should be considered separately. It will be
                  O(a+b).
                </p>
                <p>
                  4. Drop the non dominant terms. In
                  <a
                    href="https://github.com/jeeves1618/DSandAlgo/blob/master/exercises/logpairsofarray.js"
                    >this example</a
                  >, we are iterating the array once to print the elements. We
                  are then having nested loop to print all the pairs. So, it is
                  basically O(N + N^2). Out of these N^2 is the most dominant
                  term. So, we can ignore O(N) and say this program has the time
                  complexity of O(N^2).
                </p>
              </div>
            </article>
          </li>
          <li class="topic-item">
            <article>
              <div class="topic-item-content">
                <h2 class="content">Space Complexity</h2>
                <p>
                  When we talk about space complexity, we have to think in terms
                  of heap and stack. Heap is where we usually store the
                  variables. Stack is where we usually store the function calls.
                </p>
                <p>So, what causes the space complexity?</p>
                <p>
                  1. Variables<br />
                  2. Data Structures (lists, maps etc.)<br />
                  3. Function calls<br />
                  4. Other allocations
                </p>
              </div>
            </article>
          </li>
        </ul>
      </section>
    </main>

    <footer></footer>
  </body>
</html>
